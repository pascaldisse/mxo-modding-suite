<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Matrix Online NPC Dialogue Editor</title>
    
    <!-- External Dependencies -->
    <script src="https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js"></script>
    <!-- Note: For production, precompile scripts instead of using in-browser Babel transformer -->
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone@7.23.5/babel.min.js"></script>
    
    <!-- Three.js ES Modules -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        
        // Make THREE globally available
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        window.GLTFLoader = GLTFLoader;
    </script>
    
    <!-- Tailwind CSS (Note: For production, use the CLI or PostCSS plugin instead) -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Monaco Editor -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs/loader.js"></script>
    
    <style>
        /* Matrix theme styling */
        :root {
            --matrix-green: #00ff00;
            --matrix-dark: #001a00;
            --matrix-black: #000800;
            --matrix-light: #ccffcc;
        }
        
        body {
            margin: 0;
            padding: 0;
            font-family: 'Courier New', monospace;
            background-color: var(--matrix-black);
            color: var(--matrix-green);
        }
        
        .matrix-button {
            background-color: var(--matrix-dark);
            color: var(--matrix-green);
            border: 1px solid var(--matrix-green);
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .matrix-button:hover {
            background-color: var(--matrix-green);
            color: var(--matrix-black);
        }
        
        .matrix-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .matrix-button:disabled:hover {
            background-color: var(--matrix-dark);
            color: var(--matrix-green);
        }
        
        .matrix-header {
            background-color: var(--matrix-dark);
            border-bottom: 2px solid var(--matrix-green);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .matrix-title {
            font-size: 24px;
            font-weight: bold;
            color: var(--matrix-green);
            letter-spacing: 2px;
        }
        
        .npc-list {
            height: calc(100vh - 60px);
            overflow-y: auto;
            background-color: var(--matrix-dark);
            border-right: 1px solid var(--matrix-green);
            width: 250px;
        }
        
        .npc-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(0, 255, 0, 0.2);
        }
        
        .npc-item:hover {
            background-color: rgba(0, 255, 0, 0.1);
        }
        
        .npc-item.selected {
            background-color: rgba(0, 255, 0, 0.2);
        }
        
        .model-preview {
            height: 300px;
            background-color: var(--matrix-dark);
            border: 1px solid var(--matrix-green);
        }
        
        .dialogue-editor {
            background-color: var(--matrix-black);
            border: 1px solid var(--matrix-green);
            height: calc(100vh - 430px);
        }
        
        .audio-player {
            background-color: var(--matrix-dark);
            border: 1px solid var(--matrix-green);
            padding: 10px;
            margin-top: 10px;
        }
        
        .search-box {
            background-color: var(--matrix-dark);
            border: 1px solid var(--matrix-green);
            color: var(--matrix-green);
            padding: 5px 10px;
            width: 100%;
            margin-bottom: 10px;
        }
        
        .dialogue-container {
            padding: 15px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .loading-matrix {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: var(--matrix-black);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        
        .loading-text {
            font-size: 24px;
            color: var(--matrix-green);
            margin-top: 20px;
            font-family: 'Courier New', monospace;
        }
        
        .matrix-rain {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.5;
        }
        
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 8, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        /* Tailwind-like utility classes */
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .flex-row { flex-direction: row; }
        .items-center { align-items: center; }
        .justify-between { justify-content: space-between; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .m-2 { margin: 0.5rem; }
        .mt-2 { margin-top: 0.5rem; }
        .mb-2 { margin-bottom: 0.5rem; }
        .text-sm { font-size: 0.875rem; }
        .text-xs { font-size: 0.75rem; }
        .border { border-width: 1px; }
        .rounded { border-radius: 0.25rem; }
    </style>
</head>
<body>
    <div id="loading" class="loading-matrix">
        <canvas id="matrix-rain" class="matrix-rain"></canvas>
        <div class="loading-text" id="loading-text">Initializing NPC Dialogue Editor...</div>
    </div>
    
    <div id="root"></div>

    <script type="text/babel">
        // Matrix Digital Rain Animation
        const initMatrixRain = () => {
            const canvas = document.getElementById('matrix-rain');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%";
            const fontSize = 14;
            const columns = canvas.width / fontSize;
            
            const drops = [];
            for (let i = 0; i < columns; i++) {
                drops[i] = 1;
            }
            
            const drawMatrix = () => {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.fillStyle = '#00ff00';
                ctx.font = fontSize + 'px monospace';
                
                for (let i = 0; i < drops.length; i++) {
                    const text = matrix[Math.floor(Math.random() * matrix.length)];
                    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                    
                    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                        drops[i] = 0;
                    }
                    
                    drops[i]++;
                }
            };
            
            setInterval(drawMatrix, 33);
        };
        
        // Main React Application
        const { useState, useEffect, useRef } = React;
        
        // Data structure for NPC dialogues
        const NPC_DIALOGUE_FORMAT = {
            // Typical message file structure for NPCs in MxO
            MSG_HEADER: {
                signature: 'MSG',
                version: 1.0,
                entryCount: 0
            },
            MSG_ENTRY: {
                id: 0,              // Unique ID for this dialogue entry
                npcId: 0,           // ID of the NPC speaking this line
                dialogueType: 0,    // Type (greeting, response, quest, etc)
                nextDialogueId: -1, // Next dialogue in sequence (-1 for none)
                audioFile: '',      // Reference to audio file
                text: ''            // The actual dialogue text
            }
        };
        
        // Message file parser
        const parseMessageFile = async (file) => {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        const dialogues = [];
                        
                        // Log file content for debugging
                        console.log(`===== DIALOGUE FILE: ${file.name} =====`);
                        if (typeof content === 'string') {
                            // Log first 500 chars of content
                            console.log(content.slice(0, 500) + (content.length > 500 ? '...' : ''));
                            
                            // Check if it has any dialogue-like content
                            const hasQuotes = content.includes('"') && content.includes('"');
                            const hasBrackets = content.includes('[') && content.includes(']');
                            const hasDialogueMarkers = content.includes('ID:') || content.includes('Type:');
                            
                            console.log(`File contains quotes: ${hasQuotes}, brackets: ${hasBrackets}, dialogue markers: ${hasDialogueMarkers}`);
                        } else {
                            console.log('Binary content (not displayed)');
                        }
                        console.log('===== END FILE CONTENT =====');
                        
                        // There are two possible formats we'll try to parse:
                        // 1. Binary .MSG format
                        // 2. Text-based dialogue format
                        
                        // First, try to parse as a text file
                        if (typeof content === 'string') {
                            // Extract any sentences that look like dialogue (contain quotes)
                            const quoteMatches = content.match(/"([^"]+)"/g);
                            if (quoteMatches && quoteMatches.length > 0) {
                                console.log(`Found ${quoteMatches.length} quoted strings that could be dialogue`);
                                
                                // Create dialogue entries from quotes
                                for (let i = 0; i < Math.min(quoteMatches.length, 10); i++) {
                                    // Remove quotes around the text
                                    const text = quoteMatches[i].slice(1, -1);
                                    dialogues.push({
                                        id: i + 1,
                                        npcId: 0, // Will be assigned based on filename or content
                                        dialogueType: i === 0 ? 1 : 2, // First is greeting, rest are conversation
                                        nextDialogueId: i < quoteMatches.length - 1 ? i + 2 : -1,
                                        audioFile: '',
                                        text: text
                                    });
                                }
                            } else {
                                // Simple text format parser
                                const lines = content.split(/\r?\n/);
                                let currentDialogue = null;
                                
                                for (let i = 0; i < lines.length; i++) {
                                    const line = lines[i].trim();
                                    
                                    // Skip empty lines and comments
                                    if (!line || line.startsWith('//') || line.startsWith('#')) {
                                        continue;
                                    }
                                    
                                    // Check for dialogue ID marker
                                    if (line.startsWith('[') && line.includes(']')) {
                                        // New dialogue entry
                                        if (currentDialogue) {
                                            dialogues.push(currentDialogue);
                                        }
                                        
                                        // Parse ID from format like [ID:1001]
                                        const idMatch = line.match(/\[ID:(\d+)\]/);
                                        const typeMatch = line.match(/\(Type:(\d+)\)/);
                                        
                                        currentDialogue = {
                                            id: idMatch ? parseInt(idMatch[1]) : dialogues.length + 1,
                                            npcId: 0, // Will be assigned based on filename or content
                                            dialogueType: typeMatch ? parseInt(typeMatch[1]) : 0,
                                            nextDialogueId: -1,
                                            audioFile: '',
                                            text: ''
                                        };
                                        
                                        // Check for quoted text in the same line
                                        const textMatch = line.match(/"([^"]*)"/);
                                        if (textMatch) {
                                            currentDialogue.text = textMatch[1];
                                        }
                                    } 
                                    // Audio file reference
                                    else if (line.startsWith('Audio:') && currentDialogue) {
                                        currentDialogue.audioFile = line.substring(6).trim();
                                    }
                                    // Next dialogue reference
                                    else if (line.startsWith('Next:') && currentDialogue) {
                                        const nextId = parseInt(line.substring(5).trim());
                                        currentDialogue.nextDialogueId = isNaN(nextId) ? -1 : nextId;
                                    }
                                    // Plain text (must be part of dialogue)
                                    else if (currentDialogue && !currentDialogue.text) {
                                        currentDialogue.text = line;
                                    }
                                }
                                
                                // Add the last dialogue entry if exists
                                if (currentDialogue) {
                                    dialogues.push(currentDialogue);
                                }
                                
                                // If no structured dialogue was found, create dialogue from text lines
                                if (dialogues.length === 0 && lines.length > 0) {
                                    const nonEmptyLines = lines.filter(line => 
                                        line.trim() && !line.startsWith('#') && !line.startsWith('//')
                                    );
                                    
                                    if (nonEmptyLines.length > 0) {
                                        console.log(`Creating ${Math.min(nonEmptyLines.length, 5)} dialogue entries from unstructured text`);
                                        
                                        for (let i = 0; i < Math.min(nonEmptyLines.length, 5); i++) {
                                            dialogues.push({
                                                id: i + 1,
                                                npcId: 0, // Will be assigned later
                                                dialogueType: i === 0 ? 1 : 2, // First is greeting, rest are conversation
                                                nextDialogueId: i < 4 ? i + 2 : -1,
                                                audioFile: '',
                                                text: nonEmptyLines[i].slice(0, 200) // Limit length
                                            });
                                        }
                                    }
                                }
                            }
                        } 
                        // Try to parse as binary (for actual .MSG files)
                        else {
                            // In a real implementation, we'd parse the binary format
                            // For this demo, we'll return a placeholder message
                            dialogues.push({
                                id: 1,
                                npcId: 1,
                                dialogueType: 1,
                                nextDialogueId: -1,
                                audioFile: '',
                                text: "Binary MSG file detected. Binary parsing would be implemented in a full version."
                            });
                        }
                        
                        if (dialogues.length > 0) {
                            console.log(`Successfully parsed ${dialogues.length} dialogue entries from ${file.name}`);
                        } else {
                            console.log(`No dialogue entries found in ${file.name}`);
                        }
                        
                        resolve(dialogues);
                    } catch (error) {
                        console.error('Error parsing message file:', error);
                        reject(error);
                    }
                };
                
                reader.onerror = (error) => {
                    reject(error);
                };
                
                // Try to read most files as text first since that's more likely to work
                // Only use binary for known binary formats
                const lcName = file.name.toLowerCase();
                if (lcName.endsWith('.bin') || 
                    lcName.endsWith('.dat') || 
                    lcName.endsWith('.abc') || 
                    lcName.endsWith('.mob')) {
                    // Read these as binary
                    reader.readAsArrayBuffer(file);
                } else {
                    // Try to read all other files (including .msg) as text first
                    reader.readAsText(file);
                }
            });
        };
        
        // NPC identification from files
        const identifyNPCFromFiles = (files) => {
            // Group files by potential NPC
            const npcMap = new Map();
            const npcList = [];
            
            // First, process model files
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const filename = file.name.toLowerCase();
                const path = file.webkitRelativePath || '';
                
                // Skip system files and hidden files
                if (filename.startsWith('.') || 
                    filename === 'thumbs.db' || 
                    filename === 'desktop.ini') {
                    continue;
                }
                
                // Check if it's a character model file
                if (filename.endsWith('.abc') || 
                    filename.endsWith('.mob') || 
                    path.includes('/characters/') || 
                    path.includes('/npcs/')) {
                    
                    // Extract potential NPC name from filename or path
                    let npcName = '';
                    
                    // Try to extract from path segments
                    const pathParts = path.split('/');
                    if (pathParts.length > 2) {
                        // Check if we have a character name in the path
                        for (let j = 0; j < pathParts.length; j++) {
                            const part = pathParts[j].toLowerCase();
                            if (part === 'characters' || part === 'npcs') {
                                // The next segment might be a faction, and the one after a name
                                if (j + 2 < pathParts.length) {
                                    npcName = pathParts[j+2].replace(/\.\w+$/, '');
                                    break;
                                } else if (j + 1 < pathParts.length) {
                                    npcName = pathParts[j+1].replace(/\.\w+$/, '');
                                    break;
                                }
                            }
                        }
                    }
                    
                    // If we couldn't extract from path, try filename
                    if (!npcName) {
                        // Remove extension and clean up
                        npcName = filename.replace(/\.\w+$/, '');
                    }
                    
                    // Format NPC name nicely
                    npcName = npcName
                        .split(/[_\-\s]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');
                    
                    // Check if we already have this NPC
                    if (!npcMap.has(npcName)) {
                        const npcId = npcList.length + 1;
                        const npc = {
                            id: npcId,
                            name: npcName,
                            modelFile: path,
                            dialogueFiles: [],
                            faction: determineFaction(path),
                            location: determineLocation(path),
                            thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
                        };
                        
                        npcMap.set(npcName, npc);
                        npcList.push(npc);
                    }
                }
            }
            
            // Next, associate dialogue files with NPCs
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const filename = file.name.toLowerCase();
                const path = file.webkitRelativePath || '';
                
                // Check if it's a potential dialogue file
                if (filename.endsWith('.msg') || 
                    filename.endsWith('.txt') || 
                    filename.endsWith('.log') || 
                    filename.endsWith('.csv') || 
                    filename.includes('dialogue') ||
                    filename.includes('speech') ||
                    filename.includes('text') ||
                    filename.includes('talk') ||
                    path.includes('/dialogue/') || 
                    path.includes('/text/') ||
                    path.includes('/speech/')) {
                    
                    // Try to match with an NPC
                    for (const [npcName, npc] of npcMap.entries()) {
                        const nameParts = npcName.toLowerCase().split(' ');
                        
                        // Check if the filename contains the NPC name
                        let matches = false;
                        for (const part of nameParts) {
                            if (part.length > 2 && (filename.includes(part) || path.includes(part))) {
                                matches = true;
                                break;
                            }
                        }
                        
                        if (matches) {
                            // Add this file to the NPC's dialogue files
                            npc.dialogueFiles.push(file);
                        }
                    }
                }
            }
            
            // Create a fallback NPC for unmatched dialogue files
            let unmatchedDialogueFiles = [];
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                const filename = file.name.toLowerCase();
                
                if (filename.endsWith('.msg') || filename.endsWith('.txt')) {
                    let matched = false;
                    
                    for (const npc of npcList) {
                        if (npc.dialogueFiles.includes(file)) {
                            matched = true;
                            break;
                        }
                    }
                    
                    if (!matched) {
                        unmatchedDialogueFiles.push(file);
                    }
                }
            }
            
            // Add NPCs for any unmatched dialogue files
            if (unmatchedDialogueFiles.length > 0) {
                for (const file of unmatchedDialogueFiles) {
                    const filename = file.name.replace(/\.\w+$/, '');
                    
                    // Format NPC name nicely
                    const npcName = filename
                        .split(/[_\-\s]+/)
                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                        .join(' ');
                    
                    // Check if we already have this NPC
                    if (!npcMap.has(npcName)) {
                        const npcId = npcList.length + 1;
                        const npc = {
                            id: npcId,
                            name: npcName,
                            modelFile: '',
                            dialogueFiles: [file],
                            faction: 'Unknown',
                            location: 'Unknown',
                            thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
                        };
                        
                        npcMap.set(npcName, npc);
                        npcList.push(npc);
                    } else {
                        // Add this file to the existing NPC
                        npcMap.get(npcName).dialogueFiles.push(file);
                    }
                }
            }
            
            return npcList;
        };
        
        // Helper to determine faction from file path
        const determineFaction = (path) => {
            path = path.toLowerCase();
            
            if (path.includes('agent') || path.includes('machine')) {
                return 'Machines';
            } else if (path.includes('zion') || path.includes('rebel')) {
                return 'Zion';
            } else if (path.includes('merovingian') || path.includes('exile')) {
                return 'Exiles';
            } else if (path.includes('civilian') || path.includes('npc')) {
                return 'Civilian';
            }
            
            return 'Unknown';
        };
        
        // Helper to determine location from file path
        const determineLocation = (path) => {
            path = path.toLowerCase();
            
            if (path.includes('downtown')) {
                return 'Downtown';
            } else if (path.includes('richland')) {
                return 'Richland';
            } else if (path.includes('westview')) {
                return 'Westview';
            } else if (path.includes('club_hel') || path.includes('clubhel')) {
                return 'Club Hel';
            } else if (path.includes('zion')) {
                return 'Zion';
            }
            
            return 'Unknown';
        };
        
        // NPC data structure
        const NPC_DATA_STRUCTURE = {
            id: 0,
            name: '',
            modelFile: '',     // Path to the 3D model file
            dialogueFiles: [], // Array of message files containing dialogues
            faction: '',       // Which faction this NPC belongs to
            location: '',      // Where the NPC can be found
            thumbnail: ''      // Small image representation
        };
        
        // Mock NPC data (in a real implementation, this would be loaded from game files)
        const MOCK_NPCS = [
            {
                id: 1,
                name: 'Agent Smith',
                modelFile: 'characters/agents/smith.abc',
                dialogueFiles: ['dialogues/agent_smith.msg'],
                faction: 'Machines',
                location: 'Downtown',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 2,
                name: 'Morpheus',
                modelFile: 'characters/zion/morpheus.abc',
                dialogueFiles: ['dialogues/morpheus.msg'],
                faction: 'Zion',
                location: 'Zion Control',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 3,
                name: 'Persephone',
                modelFile: 'characters/exiles/persephone.abc',
                dialogueFiles: ['dialogues/persephone.msg'],
                faction: 'Exiles',
                location: 'Club Hel',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 4,
                name: 'Seraph',
                modelFile: 'characters/exiles/seraph.abc',
                dialogueFiles: ['dialogues/seraph.msg'],
                faction: 'Exiles',
                location: 'Teahouse',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 5,
                name: 'The Oracle',
                modelFile: 'characters/exiles/oracle.abc',
                dialogueFiles: ['dialogues/oracle.msg'],
                faction: 'Exiles',
                location: 'Oracle Apartment',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 6,
                name: 'Niobe',
                modelFile: 'characters/zion/niobe.abc',
                dialogueFiles: ['dialogues/niobe.msg'],
                faction: 'Zion',
                location: 'Zion Command',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            },
            {
                id: 7,
                name: 'The Merovingian',
                modelFile: 'characters/exiles/merovingian.abc',
                dialogueFiles: ['dialogues/merovingian.msg'],
                faction: 'Exiles',
                location: 'The Restaurant',
                thumbnail: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=='
            }
        ];
        
        // Mock dialogue data
        const MOCK_DIALOGUES = {
            'Agent Smith': [
                {
                    id: 101,
                    npcId: 1,
                    dialogueType: 1, // Greeting
                    nextDialogueId: 102,
                    audioFile: 'audio/agent_smith/greeting01.wav',
                    text: "Mr. Anderson. We've been expecting you."
                },
                {
                    id: 102,
                    npcId: 1,
                    dialogueType: 2, // Conversation
                    nextDialogueId: 103,
                    audioFile: 'audio/agent_smith/convo01.wav',
                    text: "It seems that you've been living two lives, Mr. Anderson."
                },
                {
                    id: 103,
                    npcId: 1, 
                    dialogueType: 3, // Threat
                    nextDialogueId: -1,
                    audioFile: 'audio/agent_smith/threat01.wav',
                    text: "Human beings are a disease. You are a plague and we are the cure."
                }
            ],
            'Morpheus': [
                {
                    id: 201,
                    npcId: 2,
                    dialogueType: 1, // Greeting
                    nextDialogueId: 202,
                    audioFile: 'audio/morpheus/greeting01.wav',
                    text: "Welcome to the real world."
                },
                {
                    id: 202,
                    npcId: 2,
                    dialogueType: 2, // Conversation
                    nextDialogueId: 203,
                    audioFile: 'audio/morpheus/convo01.wav',
                    text: "What you know you can't explain, but you feel it. You've felt it your entire life."
                },
                {
                    id: 203,
                    npcId: 2,
                    dialogueType: 4, // Quest
                    nextDialogueId: -1,
                    audioFile: 'audio/morpheus/quest01.wav',
                    text: "I'm trying to free your mind, Neo. But I can only show you the door. You're the one that has to walk through it."
                }
            ]
        };
        
        // 3D Model Viewer Component
        const ModelViewer = ({ modelFile }) => {
            const containerRef = useRef(null);
            const [isLoading, setIsLoading] = useState(true);
            
            useEffect(() => {
                if (!containerRef.current) return;
                
                // Set up Three.js scene
                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x001a00);
                
                // Add lights
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0x00ff00, 1);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Add camera
                const camera = new THREE.PerspectiveCamera(
                    75,
                    containerRef.current.clientWidth / containerRef.current.clientHeight,
                    0.1,
                    1000
                );
                camera.position.z = 5;
                
                // Create renderer
                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(containerRef.current.clientWidth, containerRef.current.clientHeight);
                containerRef.current.appendChild(renderer.domElement);
                
                // Add controls
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                
                // Load a placeholder model (in a real app, we'd load the actual model)
                const geometry = new THREE.BoxGeometry(1, 2, 1);
                const material = new THREE.MeshPhongMaterial({ 
                    color: 0x00ff00, 
                    wireframe: true,
                    emissive: 0x003300
                });
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
                
                // Animation loop
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    cube.rotation.y += 0.01;
                    renderer.render(scene, camera);
                };
                
                animate();
                setIsLoading(false);
                
                // Cleanup
                return () => {
                    if (containerRef.current) {
                        containerRef.current.removeChild(renderer.domElement);
                    }
                    
                    // Dispose of Three.js resources
                    geometry.dispose();
                    material.dispose();
                    renderer.dispose();
                };
            }, [modelFile]);
            
            return (
                <div className="model-preview w-full" ref={containerRef}>
                    {isLoading && <div className="p-4 text-center">Loading model...</div>}
                </div>
            );
        };
        
        // Audio Player Component
        const AudioPlayer = ({ audioFile }) => {
            return (
                <div className="audio-player w-full">
                    <h3 className="mb-2">Voice Sample</h3>
                    <audio controls className="w-full">
                        <source src={audioFile || '#'} type="audio/wav" />
                        Your browser does not support the audio element.
                    </audio>
                    <div className="flex justify-between mt-2">
                        <button className="matrix-button text-xs">Record New</button>
                        <button className="matrix-button text-xs">Import</button>
                        <button className="matrix-button text-xs">Export</button>
                    </div>
                </div>
            );
        };
        
        // Monaco Editor Setup for Dialogue Editing
        const DialogueEditor = ({ dialogues, onSave }) => {
            const editorRef = useRef(null);
            const containerRef = useRef(null);
            const [editorValue, setEditorValue] = useState('');
            const [isEditorReady, setIsEditorReady] = useState(false);
            
            // Format dialogues into text format
            const formatDialoguesToText = (dialogueArray) => {
                if (!dialogueArray || dialogueArray.length === 0) {
                    return '# No dialogues found. Add new dialogues using the "Add Dialogue" button.';
                }
                
                return dialogueArray.map(d => {
                    // Get dialogue type name
                    let typeName = 'Unknown';
                    switch (d.dialogueType) {
                        case 1: typeName = 'Greeting'; break;
                        case 2: typeName = 'Conversation'; break;
                        case 3: typeName = 'Threat'; break;
                        case 4: typeName = 'Quest'; break;
                        case 5: typeName = 'Information'; break;
                        default: typeName = `Type ${d.dialogueType}`;
                    }
                    
                    return `[ID:${d.id}] (Type:${d.dialogueType}) "${d.text}"\n` +
                           `# ${typeName}\n` +
                           `Audio: ${d.audioFile || 'None'}\n` +
                           `Next: ${d.nextDialogueId}\n`;
                }).join('\n\n');
            };
            
            // Parse text back to dialogue objects
            const parseTextToDialogues = (text) => {
                const dialogueEntries = [];
                const blocks = text.split(/\n\n+/);
                
                for (const block of blocks) {
                    if (!block.trim() || block.trim().startsWith('#')) continue;
                    
                    const lines = block.split(/\r?\n/);
                    let currentDialogue = null;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();
                        
                        // Skip empty lines and comments
                        if (!line || line.startsWith('#')) continue;
                        
                        // Check for dialogue ID marker
                        if (line.startsWith('[') && line.includes(']')) {
                            // Extract ID and type
                            const idMatch = line.match(/\[ID:(\d+)\]/);
                            const typeMatch = line.match(/\(Type:(\d+)\)/);
                            const textMatch = line.match(/"([^"]*)"/);
                            
                            currentDialogue = {
                                id: idMatch ? parseInt(idMatch[1]) : dialogueEntries.length + 1,
                                npcId: (dialogues && dialogues.length > 0) ? dialogues[0].npcId : 0,
                                dialogueType: typeMatch ? parseInt(typeMatch[1]) : 0,
                                nextDialogueId: -1,
                                audioFile: '',
                                text: textMatch ? textMatch[1] : ''
                            };
                            
                            dialogueEntries.push(currentDialogue);
                        } 
                        // Audio file reference
                        else if (line.startsWith('Audio:') && currentDialogue) {
                            const audioPath = line.substring(6).trim();
                            if (audioPath && audioPath.toLowerCase() !== 'none') {
                                currentDialogue.audioFile = audioPath;
                            }
                        }
                        // Next dialogue reference
                        else if (line.startsWith('Next:') && currentDialogue) {
                            const nextId = parseInt(line.substring(5).trim());
                            currentDialogue.nextDialogueId = isNaN(nextId) ? -1 : nextId;
                        }
                    }
                }
                
                return dialogueEntries;
            };
            
            // Initialize the editor
            useEffect(() => {
                if (!containerRef.current) return;
                
                // Initialize Monaco Editor
                require.config({ paths: { 'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.43.0/min/vs' }});
                
                require(['vs/editor/editor.main'], () => {
                    // Format the dialogues
                    const formattedText = formatDialoguesToText(dialogues);
                    setEditorValue(formattedText);
                    
                    // Create editor if it doesn't exist
                    if (!editorRef.current) {
                        // Custom Matrix theme
                        monaco.editor.defineTheme('matrix-theme', {
                            base: 'vs-dark',
                            inherit: true,
                            rules: [
                                { token: 'comment', foreground: '008800' },
                                { token: 'string', foreground: '00ff00' },
                                { token: 'number', foreground: '00dd00' },
                                { token: 'keyword', foreground: '00ff44' }
                            ],
                            colors: {
                                'editor.background': '#000800',
                                'editor.foreground': '#00ff00',
                                'editor.lineHighlightBackground': '#003300',
                                'editorCursor.foreground': '#00ff00',
                                'editorWhitespace.foreground': '#005500'
                            }
                        });
                        
                        // Define a simple language for dialogue files
                        monaco.languages.register({ id: 'dialogueScript' });
                        monaco.languages.setMonarchTokensProvider('dialogueScript', {
                            tokenizer: {
                                root: [
                                    [/^#.*$/, 'comment'],
                                    [/\[ID:\d+\]/, 'keyword'],
                                    [/\(Type:\d+\)/, 'keyword'],
                                    [/"[^"]*"/, 'string'],
                                    [/Audio:.*$/, 'keyword'],
                                    [/Next:.*$/, 'keyword'],
                                    [/\d+/, 'number']
                                ]
                            }
                        });
                        
                        // Create the editor
                        editorRef.current = monaco.editor.create(containerRef.current, {
                            value: formattedText,
                            language: 'dialogueScript',
                            theme: 'matrix-theme',
                            minimap: { enabled: true },
                            automaticLayout: true,
                            fontSize: 14,
                            lineNumbers: 'on',
                            scrollBeyondLastLine: false,
                            wordWrap: 'on'
                        });
                        
                        // Set up change listener
                        editorRef.current.onDidChangeModelContent(() => {
                            const newValue = editorRef.current.getValue();
                            setEditorValue(newValue);
                        });
                        
                        setIsEditorReady(true);
                    } else {
                        editorRef.current.setValue(formattedText);
                    }
                });
                
                return () => {
                    if (editorRef.current) {
                        editorRef.current.dispose();
                        editorRef.current = null;
                        setIsEditorReady(false);
                    }
                };
            }, [dialogues]);
            
            // Save handler
            const handleSave = () => {
                if (isEditorReady && editorRef.current) {
                    const currentText = editorRef.current.getValue();
                    const parsedDialogues = parseTextToDialogues(currentText);
                    
                    if (parsedDialogues.length > 0) {
                        if (onSave) {
                            onSave(parsedDialogues);
                        }
                    }
                }
            };
            
            // Expose save method to parent
            useEffect(() => {
                if (isEditorReady && onSave) {
                    containerRef.current.save = handleSave;
                }
            }, [isEditorReady, onSave]);
            
            return (
                <div className="dialogue-editor w-full" ref={containerRef}></div>
            );
        };
        
        // Main App Component
        const App = () => {
            const [gameDirectory, setGameDirectory] = useState(null);
            const [npcs, setNpcs] = useState(MOCK_NPCS);
            const [selectedNpc, setSelectedNpc] = useState(null);
            const [dialogues, setDialogues] = useState([]);
            const [searchTerm, setSearchTerm] = useState('');
            const [isLoading, setIsLoading] = useState(false);
            
            // Initialize global dialogue data with mock data
            useEffect(() => {
                window.npcDialogueData = MOCK_DIALOGUES;
            }, []);
            
            useEffect(() => {
                // Initialize matrix rain animation
                initMatrixRain();
                
                // Simulate loading screen
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 2000);
            }, []);
            
            const handleSelectGameDirectory = async () => {
                setIsLoading(true);
                
                try {
                    // Alternative approach using input type="file" for better compatibility
                    // Create a file input element
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.webkitdirectory = true; // Chrome, Edge, Opera, Safari
                    fileInput.directory = true; // Firefox (though not fully supported)
                    fileInput.multiple = true;
                    
                    // Set up the change event handler
                    fileInput.onchange = (event) => {
                        // Get selected files
                        const files = event.target.files;
                        
                        if (files && files.length > 0) {
                            // Determine the common directory path
                            // Get the first file's path and extract the directory
                            const firstFile = files[0];
                            const pathParts = firstFile.webkitRelativePath.split('/');
                            const dirName = pathParts[0]; // The root directory name
                            
                            console.log(`Selected directory: ${dirName} with ${files.length} files`);
                            
                            // Set the game directory
                            setGameDirectory(dirName);
                            
                            // Log file extensions for diagnostic purposes
                            const fileExtensions = {};
                            let msgFiles = 0;
                            let txtFiles = 0;
                            
                            for (let i = 0; i < files.length; i++) {
                                const ext = files[i].name.split('.').pop().toLowerCase();
                                fileExtensions[ext] = (fileExtensions[ext] || 0) + 1;
                                
                                if (ext === 'msg') msgFiles++;
                                if (ext === 'txt') txtFiles++;
                            }
                            
                            console.log('File extensions found:', fileExtensions);
                            console.log(`Found ${msgFiles} .msg files and ${txtFiles} .txt files that could contain dialogue`);
                            
                            // Reset global dialogue data
                            window.npcDialogueData = null;
                            
                            // Process the files to identify NPCs and dialogues
                            try {
                                // Identify NPCs from the selected files
                                const identifiedNpcs = identifyNPCFromFiles(files);
                                console.log(`Identified ${identifiedNpcs.length} NPCs`);
                                
                                if (identifiedNpcs.length > 0) {
                                    // Replace mock data with actual identified NPCs
                                    setNpcs(identifiedNpcs);
                                    
                                    // Process dialogue files for each NPC
                                    const processNpcDialogues = async () => {
                                        const npcDialogueMap = {};
                                        
                                        for (const npc of identifiedNpcs) {
                                            if (npc.dialogueFiles && npc.dialogueFiles.length > 0) {
                                                // Process each dialogue file
                                                try {
                                                    const dialoguePromises = npc.dialogueFiles.map(file => parseMessageFile(file));
                                                    const dialogueResults = await Promise.all(dialoguePromises);
                                                    
                                                    // Combine all dialogues for this NPC
                                                    const allDialogues = dialogueResults.flat();
                                                    
                                                    // Assign NPC ID to each dialogue entry
                                                    allDialogues.forEach(dialogue => {
                                                        dialogue.npcId = npc.id;
                                                    });
                                                    
                                                    // Store in the map
                                                    npcDialogueMap[npc.name] = allDialogues;
                                                } catch (error) {
                                                    console.error(`Error processing dialogues for NPC ${npc.name}:`, error);
                                                }
                                            }
                                        }
                                        
                                        // If we have no dialogue, try a more aggressive approach:
                                        // Parse any text files and try to extract dialogue
                                        if (Object.keys(npcDialogueMap).length === 0) {
                                            console.log('No dialogues found with standard parsing. Trying aggressive parsing...');
                                            
                                            // Get all text files
                                            const textFiles = [];
                                            for (let i = 0; i < files.length; i++) {
                                                const file = files[i];
                                                const ext = file.name.split('.').pop().toLowerCase();
                                                if (ext === 'txt' || ext === 'log' || ext === 'csv' || ext === 'msg') {
                                                    textFiles.push(file);
                                                }
                                            }
                                            
                                            if (textFiles.length > 0) {
                                                console.log(`Found ${textFiles.length} text files to parse aggressively`);
                                                
                                                // Create generic NPCs from text files
                                                for (let i = 0; i < Math.min(textFiles.length, 10); i++) {
                                                    const file = textFiles[i];
                                                    const npcName = file.name.replace(/\.\w+$/, '')
                                                        .split(/[_\-\s]+/)
                                                        .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                                                        .join(' ');
                                                        
                                                    try {
                                                        const reader = new FileReader();
                                                        reader.onload = (e) => {
                                                            try {
                                                                const content = e.target.result;
                                                                if (typeof content === 'string') {
                                                                    // Extract first few lines for dialogue
                                                                    const lines = content.split(/\r?\n/).filter(line => 
                                                                        line.trim() && !line.startsWith('#') && !line.startsWith('//')
                                                                    );
                                                                    
                                                                    if (lines.length > 0) {
                                                                        const dialogueEntries = [];
                                                                        for (let j = 0; j < Math.min(lines.length, 5); j++) {
                                                                            dialogueEntries.push({
                                                                                id: j + 1,
                                                                                npcId: identifiedNpcs.length + i + 1,
                                                                                dialogueType: j === 0 ? 1 : 2, // First is greeting, rest are conversation
                                                                                nextDialogueId: j < 4 ? j + 2 : -1,
                                                                                audioFile: '',
                                                                                text: lines[j].slice(0, 200) // Limit length
                                                                            });
                                                                        }
                                                                        
                                                                        npcDialogueMap[npcName] = dialogueEntries;
                                                                        console.log(`Added ${dialogueEntries.length} dialogue entries for ${npcName} from file`);
                                                                    }
                                                                }
                                                            } catch (error) {
                                                                console.error(`Error parsing ${file.name}:`, error);
                                                            }
                                                        };
                                                        reader.readAsText(file);
                                                    } catch (error) {
                                                        console.error(`Error reading ${file.name}:`, error);
                                                    }
                                                }
                                            }
                                        }
                                        
                                        // Use the identified dialogues
                                        if (Object.keys(npcDialogueMap).length > 0) {
                                            setDialogues([]); // Clear any current dialogues
                                            console.log('Parsed dialogue map:', npcDialogueMap);
                                            
                                            // Store the dialogue map for lookup
                                            window.npcDialogueData = npcDialogueMap;
                                        } else {
                                            console.log('No dialogues found in any files. Using mock data.');
                                            
                                            // If we couldn't parse any real dialogues, use the mock data
                                            window.npcDialogueData = MOCK_DIALOGUES;
                                        }
                                        
                                        // DIAGNOSTIC - Create synthetic dialogue entries for NPCs with no dialogue
                                        for (const npc of identifiedNpcs) {
                                            if (!window.npcDialogueData || !window.npcDialogueData[npc.name]) {
                                                console.log(`Creating synthetic dialogue for ${npc.name}`);
                                                
                                                // Initialize if not exists
                                                if (!window.npcDialogueData) {
                                                    window.npcDialogueData = {};
                                                }
                                                
                                                window.npcDialogueData[npc.name] = [{
                                                    id: 1,
                                                    npcId: npc.id,
                                                    dialogueType: 1,
                                                    nextDialogueId: -1,
                                                    audioFile: '',
                                                    text: `Synthetic dialogue for ${npc.name}. No actual dialogue file was found.`
                                                }];
                                            } else {
                                                console.log(`Using real dialogue for ${npc.name} (${window.npcDialogueData[npc.name].length} entries)`);
                                            }
                                        }
                                        
                                        setIsLoading(false);
                                    };
                                    
                                    // Start processing dialogues
                                    processNpcDialogues();
                                } else {
                                    // If we couldn't identify any NPCs, fall back to mock data
                                    console.log('No NPCs identified, using mock data');
                                    setIsLoading(false);
                                }
                            } catch (error) {
                                console.error('Error processing files:', error);
                                setIsLoading(false);
                            }
                        } else {
                            // No files selected
                            setIsLoading(false);
                        }
                    };
                    
                    // Trigger the file dialog
                    fileInput.click();
                    
                    // Store the current timestamp to handle potential cancellation
                    const startTime = Date.now();
                    
                    // Handle potential cancellation
                    setTimeout(() => {
                        // If we're still loading after 5 seconds, user probably canceled
                        // We use a direct check rather than relying on a closure over isLoading
                        const currentState = document.getElementById('loading-overlay-active');
                        if (currentState && Date.now() - startTime >= 5000) {
                            setIsLoading(false);
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error('Directory selection error:', error);
                    alert('Error selecting directory: ' + error.message);
                    setIsLoading(false);
                }
            };
            
            const handleSelectNpc = (npc) => {
                setSelectedNpc(npc);
                
                // Load dialogues for this NPC from the parsed data or fallback to mock data
                if (window.npcDialogueData && window.npcDialogueData[npc.name]) {
                    setDialogues(window.npcDialogueData[npc.name]);
                } else if (MOCK_DIALOGUES[npc.name]) {
                    setDialogues(MOCK_DIALOGUES[npc.name]);
                } else {
                    // If no dialogues found, create a placeholder
                    setDialogues([{
                        id: 1,
                        npcId: npc.id,
                        dialogueType: 1,
                        nextDialogueId: -1,
                        audioFile: '',
                        text: `No dialogue found for ${npc.name}. Click 'Add Dialogue' to create new entries.`
                    }]);
                }
            };
            
            const handleSaveDialogues = (updatedDialogues) => {
                // In a real implementation, this would save the dialogues back to the game files
                console.log('Saving dialogues:', updatedDialogues);
                
                // Update the displayed dialogues
                setDialogues(updatedDialogues);
                
                // Update the global dialogue map
                if (window.npcDialogueData && selectedNpc) {
                    window.npcDialogueData[selectedNpc.name] = updatedDialogues;
                }
                
                // In a real app, this would write back to the file
                alert(`Saved ${updatedDialogues.length} dialogue entries for ${selectedNpc?.name || 'NPC'}`);
            };
            
            // Handle adding a new dialogue entry
            const handleAddDialogue = () => {
                if (!selectedNpc) return;
                
                // Create a new dialogue entry
                const newId = dialogues.length > 0 
                    ? Math.max(...dialogues.map(d => d.id)) + 1 
                    : 1;
                
                const newDialogue = {
                    id: newId,
                    npcId: selectedNpc.id,
                    dialogueType: 1, // Default to greeting
                    nextDialogueId: -1,
                    audioFile: '',
                    text: 'New dialogue entry'
                };
                
                // Add to current dialogues
                const updatedDialogues = [...dialogues, newDialogue];
                setDialogues(updatedDialogues);
                
                // Update global map
                if (window.npcDialogueData && selectedNpc) {
                    window.npcDialogueData[selectedNpc.name] = updatedDialogues;
                }
            };
            
            const filteredNpcs = npcs.filter(npc => 
                npc.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
                npc.faction.toLowerCase().includes(searchTerm.toLowerCase())
            );
            
            return (
                <div className="flex flex-col h-full">
                    {/* Loading overlay */}
                    {isLoading && (
                        <div className="loading-overlay" id="loading-overlay-active">
                            <div className="loading-text">Scanning directory...</div>
                        </div>
                    )}
                    
                    <div className="matrix-header">
                        <div className="matrix-title">NPC Dialogue Editor</div>
                        <div>
                            {!gameDirectory ? (
                                <button 
                                    className="matrix-button"
                                    onClick={handleSelectGameDirectory}
                                    disabled={isLoading}
                                >
                                    {isLoading ? "Loading..." : "Select Game Directory"}
                                </button>
                            ) : (
                                <div className="flex items-center">
                                    <span className="text-sm mr-2">Directory: {gameDirectory}</span>
                                    <button 
                                        className="matrix-button text-xs"
                                        onClick={handleSelectGameDirectory}
                                        disabled={isLoading}
                                    >
                                        Change
                                    </button>
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="flex flex-row h-full">
                        {/* NPC List */}
                        <div className="npc-list">
                            <div className="p-2">
                                <input
                                    type="text"
                                    className="search-box"
                                    placeholder="Search NPCs..."
                                    value={searchTerm}
                                    onChange={(e) => setSearchTerm(e.target.value)}
                                />
                                
                                <div className="text-sm mb-2">
                                    {filteredNpcs.length} NPCs found
                                </div>
                                
                                {filteredNpcs.map(npc => (
                                    <div 
                                        key={npc.id}
                                        className={`npc-item ${selectedNpc && selectedNpc.id === npc.id ? 'selected' : ''}`}
                                        onClick={() => handleSelectNpc(npc)}
                                    >
                                        <div>{npc.name}</div>
                                        <div className="text-xs">{npc.faction}</div>
                                    </div>
                                ))}
                            </div>
                        </div>
                        
                        {/* Dialogue Editor Area */}
                        <div className="dialogue-container">
                            {selectedNpc ? (
                                <>
                                    <h2>{selectedNpc.name} - {selectedNpc.faction}</h2>
                                    <div className="text-sm mb-2">Location: {selectedNpc.location}</div>
                                    
                                    {/* 3D Model Preview */}
                                    <ModelViewer modelFile={selectedNpc.modelFile} />
                                    
                                    {/* Audio Player */}
                                    <AudioPlayer audioFile={dialogues[0]?.audioFile} />
                                    
                                    {/* Dialogue Editor */}
                                    <h3 className="mt-2 mb-2">Dialogue Sequences</h3>
                                    <DialogueEditor 
                                        dialogues={dialogues}
                                        onSave={handleSaveDialogues}
                                    />
                                    
                                    <div className="flex justify-between mt-2">
                                        <button 
                                            className="matrix-button"
                                            onClick={handleAddDialogue}
                                        >
                                            Add Dialogue
                                        </button>
                                        <button 
                                            className="matrix-button"
                                            onClick={() => {
                                                // Call the editor's save method
                                                const editorContainer = document.querySelector('.dialogue-editor');
                                                if (editorContainer && editorContainer.save) {
                                                    editorContainer.save();
                                                } else {
                                                    handleSaveDialogues(dialogues);
                                                }
                                            }}
                                        >
                                            Save Changes
                                        </button>
                                        <button 
                                            className="matrix-button"
                                            onClick={() => alert('In a full implementation, this would launch the game with the current NPC loaded for testing.')}
                                        >
                                            Test In-Game
                                        </button>
                                    </div>
                                </>
                            ) : (
                                <div className="p-4 text-center">
                                    <p>Select an NPC from the list to edit their dialogue</p>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        };
        
        // Render the app
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>